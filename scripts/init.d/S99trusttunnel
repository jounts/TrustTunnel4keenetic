#!/bin/sh

ENABLED=yes
PROCS="trusttunnel_client"
DESC="TrustTunnel VPN Client"
CALLER="$0"

TT_DIR="/opt/trusttunnel_client"
TT_BIN="$TT_DIR/trusttunnel_client"
TT_CONF="$TT_DIR/trusttunnel_client.toml"
MODE_CONF="$TT_DIR/mode.conf"
LOG_FILE="/opt/var/log/trusttunnel.log"
PID_FILE="/opt/var/run/trusttunnel.pid"
WATCHDOG_PID_FILE="/opt/var/run/trusttunnel_watchdog.pid"
START_TS_FILE="/opt/var/run/trusttunnel_start_ts"
HC_STATE_FILE="/opt/var/run/trusttunnel_hc_state"
STATUS_JSON="/opt/var/run/trusttunnel_status.json"

MAX_LOG_SIZE=1048576  # 1 MB

TT_MODE="socks5"
TUN_IDX=0
PROXY_IDX=0
HC_ENABLED="yes"
HC_INTERVAL=30
HC_FAIL_THRESHOLD=3
HC_GRACE_PERIOD=60
HC_TARGET_URL="http://connectivitycheck.gstatic.com/generate_204"
HC_CURL_TIMEOUT=5
HC_SOCKS5_PROXY="127.0.0.1:1080"

# Smart routing defaults
SR_ENABLED="no"
SR_HOME_COUNTRY="RU"
SR_DNS_PORT=5354
SR_DNS_UPSTREAM="1.1.1.1"

ROUTING_STATE_FILE="/opt/var/run/tun_routing.conf"

COMPAT_SH="$TT_DIR/ndms-compat.sh"
SMART_ROUTING_SH="$TT_DIR/smart-routing.sh"

load_config() {
    [ -f "$MODE_CONF" ] && . "$MODE_CONF"
}

# Load NDMS compatibility layer
if [ -f "$COMPAT_SH" ]; then
    . "$COMPAT_SH"
fi

# Load smart routing functions
if [ -f "$SMART_ROUTING_SH" ]; then
    . "$SMART_ROUTING_SH"
fi

setup_ca_certs() {
    local entware_bundle="/opt/etc/ssl/certs/ca-certificates.crt"
    local sys_certs="/etc/ssl/certs"
    local staging="/opt/var/run/ssl-certs"

    [ ! -f "$entware_bundle" ] && return 0

    # Already mounted — nothing to do
    mount 2>/dev/null | grep -q "$sys_certs" && return 0

    # Build a writable copy of the firmware certs + Entware CA bundle
    rm -rf "$staging"
    mkdir -p "$staging"
    cp "$sys_certs"/*.crt "$staging/" 2>/dev/null
    cp "$entware_bundle" "$staging/ca-certificates.crt"

    mount --bind "$staging" "$sys_certs" 2>/dev/null
    if mount 2>/dev/null | grep -q "$sys_certs"; then
        export SSL_CERT_FILE="$sys_certs/ca-certificates.crt"
        export SSL_CERT_DIR="$sys_certs"
        log_msg "CA certificates overlay mounted on $sys_certs"
    else
        export SSL_CERT_FILE="$entware_bundle"
        export SSL_CERT_DIR="/opt/etc/ssl/certs"
        log_msg "WARNING: bind mount failed, falling back to SSL_CERT_FILE env var"
    fi
}

setup_tun_routing() {
    local tun_dev="tun${TUN_IDX}"

    # Extract VPN server IP from config
    local vpn_server_ip
    vpn_server_ip=$(grep -A5 '\[endpoint\]' "$TT_CONF" \
        | grep 'addresses' \
        | grep -oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' \
        | head -1)

    if [ -z "$vpn_server_ip" ]; then
        log_msg "WARNING: Could not extract VPN server IP, skipping routing setup"
        return 1
    fi

    # Get original default route (exclude tun interfaces)
    local route_line
    route_line=$(ip route show default 2>/dev/null | grep -v "tun" | head -n1)

    local orig_gw=""
    local orig_dev=""
    echo "$route_line" | grep -q "via" && \
        orig_gw=$(echo "$route_line" | sed -n 's/.*via \([^ ]*\).*/\1/p')
    orig_dev=$(echo "$route_line" | sed -n 's/.*dev \([^ ]*\).*/\1/p')

    if [ -z "$orig_dev" ]; then
        log_msg "WARNING: Could not detect original gateway, skipping routing setup"
        return 1
    fi

    # Save state for cleanup
    cat > "$ROUTING_STATE_FILE" << EOF
VPN_SERVER=$vpn_server_ip
ORIG_GW=$orig_gw
ORIG_DEV=$orig_dev
EOF

    # Host route for VPN server — must always go via ISP, not the tunnel
    if [ -n "$orig_gw" ]; then
        ip route add "$vpn_server_ip/32" via "$orig_gw" dev "$orig_dev" 2>/dev/null
    else
        ip route add "$vpn_server_ip/32" dev "$orig_dev" 2>/dev/null
    fi

    log_msg "VPN server route: $vpn_server_ip via ${orig_gw:-direct} dev $orig_dev"
}

activate_tun_default_route() {
    local tun_dev="tun${TUN_IDX}"
    ip route replace default dev "$tun_dev"
    log_msg "Default route switched to $tun_dev"
}

cleanup_tun_routing() {
    [ ! -f "$ROUTING_STATE_FILE" ] && return 0

    . "$ROUTING_STATE_FILE"

    # Remove host route for VPN server
    ip route del "$VPN_SERVER/32" 2>/dev/null

    # Restore original default route
    if [ -n "$ORIG_GW" ]; then
        ip route replace default via "$ORIG_GW" dev "$ORIG_DEV"
    else
        ip route replace default dev "$ORIG_DEV"
    fi

    rm -f "$ROUTING_STATE_FILE"
    log_msg "Routing restored: default via ${ORIG_GW:-direct} dev $ORIG_DEV"
}

wait_for_vpn_connected() {
    local timeout=${1:-30}
    local i=0
    while [ $i -lt $timeout ]; do
        if tail -5 "$LOG_FILE" 2>/dev/null | grep -q "VPN_SS_CONNECTED"; then
            return 0
        fi
        sleep 1
        i=$((i + 1))
    done
    log_msg "WARNING: VPN did not reach CONNECTED state within ${timeout}s"
    return 1
}

rotate_log() {
    if [ -f "$LOG_FILE" ]; then
        local size=$(wc -c < "$LOG_FILE" 2>/dev/null || echo 0)
        if [ "$size" -gt "$MAX_LOG_SIZE" ]; then
            [ -f "${LOG_FILE}.2" ] && rm -f "${LOG_FILE}.2"
            [ -f "${LOG_FILE}.1" ] && mv "${LOG_FILE}.1" "${LOG_FILE}.2"
            mv "$LOG_FILE" "${LOG_FILE}.1"
        fi
    fi
}

log_msg() {
    local ts=$(date '+%Y-%m-%d %H:%M:%S')
    echo "[$ts] $*" >> "$LOG_FILE"
}

write_status_json() {
    local running="false"
    local pid=0
    local uptime=0

    if [ -f "$PID_FILE" ] && kill -0 "$(cat "$PID_FILE" 2>/dev/null)" 2>/dev/null; then
        running="true"
        pid=$(cat "$PID_FILE")
        if [ -f "$START_TS_FILE" ]; then
            local start_ts=$(cat "$START_TS_FILE")
            local now=$(date +%s)
            uptime=$((now - start_ts))
        fi
    fi

    local hc_state="unknown"
    [ -f "$HC_STATE_FILE" ] && hc_state=$(cat "$HC_STATE_FILE")

    cat > "$STATUS_JSON" << EOF
{
  "running": $running,
  "pid": $pid,
  "uptime_seconds": $uptime,
  "mode": "$TT_MODE",
  "health_check": "$hc_state",
  "timestamp": $(date +%s)
}
EOF
}

find_free_tun_idx() {
    local target="tun${TUN_IDX}"
    if ip link show "$target" > /dev/null 2>&1; then
        log_msg "WARNING: $target already in use by another process, looking for free index"
        local try_idx=0
        while [ $try_idx -le 9 ]; do
            if ! ip link show "tun${try_idx}" > /dev/null 2>&1; then
                TUN_IDX="$try_idx"
                log_msg "Auto-selected TUN_IDX=$TUN_IDX (tun${try_idx} is free)"
                return 0
            fi
            try_idx=$((try_idx + 1))
        done
        log_msg "ERROR: No free tun interface found (tun0-tun9 all occupied)"
        return 1
    fi
    return 0
}

setup_tun_interface() {
    local tun_name="OpkgTun${TUN_IDX}"
    log_msg "Setting up TUN interface: $tun_name"

    ndm_cmd \
        "interface $tun_name" \
        "interface $tun_name description \"TrustTunnel TUN $TUN_IDX\"" \
        "interface $tun_name ip address 172.16.219.2 255.255.255.255" \
        "interface $tun_name ip global auto" \
        "interface $tun_name ip mtu 1280" \
        "interface $tun_name ip tcp adjust-mss pmtu" \
        "interface $tun_name security-level public" \
        "interface $tun_name up"

    # Wait for the kernel interface to appear and rename it.
    # NDMS creates a kernel interface for OpkgTun; its name varies by version.
    local target_name="tun${TUN_IDX}"
    local retries=0
    while [ $retries -lt 30 ]; do
        if ip link show "$target_name" > /dev/null 2>&1; then
            log_msg "Interface $target_name ready"
            break
        fi

        # Verify our NDM interface exists before searching for kernel device.
        # This prevents accidentally grabbing interfaces owned by WireGuard/OpenVPN.
        local ndm_exists=""
        ndm_exists=$(curl -sf "http://localhost:79/rci/show/interface/OpkgTun${TUN_IDX}" 2>/dev/null) || true
        if [ -z "$ndm_exists" ] || echo "$ndm_exists" | grep -q '"error"'; then
            sleep 1
            retries=$((retries + 1))
            continue
        fi

        # Only look for prefixes that NDMS uses for opkg TUN interfaces (not wg)
        local kern_name=""
        for prefix in nwg utun; do
            if ip link show "${prefix}${TUN_IDX}" > /dev/null 2>&1; then
                kern_name="${prefix}${TUN_IDX}"
                break
            fi
        done

        if [ -n "$kern_name" ]; then
            ip link set "$kern_name" name "$target_name"
            log_msg "Renamed $kern_name to $target_name (NDMS ${NDMS_MAJOR:-?})"
            break
        fi

        sleep 1
        retries=$((retries + 1))
    done
}

setup_proxy_interface() {
    local proxy_name="Proxy${PROXY_IDX}"
    log_msg "Setting up Proxy interface: $proxy_name"

    ndm_cmd \
        "interface $proxy_name" \
        "interface $proxy_name description \"TrustTunnel Proxy $PROXY_IDX\"" \
        "interface $proxy_name proxy protocol socks5" \
        "interface $proxy_name proxy upstream 127.0.0.1 1080" \
        "interface $proxy_name proxy connect" \
        "interface $proxy_name ip global auto" \
        "interface $proxy_name security-level public" \
        "system configuration save"
}

start_client() {
    if [ -f "$PID_FILE" ] && kill -0 "$(cat "$PID_FILE" 2>/dev/null)" 2>/dev/null; then
        log_msg "Already running (PID $(cat "$PID_FILE"))"
        return 0
    fi

    rotate_log
    load_config

    log_msg "Starting TrustTunnel client in $TT_MODE mode (NDMS ${NDMS_MAJOR:-?}, FW: ${NDMS_FW_BACKEND:-?})"

    # Ensure the TLS library can find CA certificates from Entware.
    # /etc/ssl/certs/ on Keenetic is read-only (squashfs) and contains
    # individual .crt files but no combined bundle. BoringSSL needs the
    # bundle file. We bind-mount a writable overlay with the bundle added.
    setup_ca_certs

    if [ "$TT_MODE" = "tun" ]; then
        if ! find_free_tun_idx; then
            log_msg "Cannot start in TUN mode: no free interface"
            return 1
        fi

        # Save original gateway before tunnel setup (needed for smart routing)
        if [ "$SR_ENABLED" = "yes" ] && type sr_save_orig_gateway > /dev/null 2>&1; then
            sr_save_orig_gateway
        fi

        setup_tun_interface

        # Apply MSS clamping for PPPoE compatibility
        if type fw_setup_mss_clamp > /dev/null 2>&1; then
            fw_setup_mss_clamp "tun${TUN_IDX}"
            log_msg "MSS clamping enabled on tun${TUN_IDX}"
        fi

        # Host route for VPN server must exist before we move the default route
        setup_tun_routing

        "$TT_BIN" --config "$TT_CONF" >> "$LOG_FILE" 2>&1 &

        # Wait for VPN to connect, then redirect all traffic through tunnel
        if wait_for_vpn_connected 30; then
            activate_tun_default_route
        fi

        # Start smart routing after tunnel is up
        if [ "$SR_ENABLED" = "yes" ] && type sr_start > /dev/null 2>&1; then
            sr_start
        fi
    else
        "$TT_BIN" --config "$TT_CONF" >> "$LOG_FILE" 2>&1 &
        sleep 2
        setup_proxy_interface
    fi

    local pid=$!
    echo "$pid" > "$PID_FILE"
    date +%s > "$START_TS_FILE"
    log_msg "Started with PID $pid"

    write_status_json
    start_watchdog
}

stop_client() {
    stop_watchdog

    # Clean up MSS clamping rules
    load_config
    if [ "$TT_MODE" = "tun" ] || [ "$TT_MODE" = "socks5-tun" ]; then
        if type fw_cleanup_mss_clamp > /dev/null 2>&1; then
            fw_cleanup_mss_clamp "tun${TUN_IDX}"
            log_msg "MSS clamping removed from tun${TUN_IDX}"
        fi
    fi

    # Restore original routing before stopping the client
    cleanup_tun_routing

    # Stop smart routing before stopping the client
    if [ "$SR_ENABLED" = "yes" ] && type sr_stop > /dev/null 2>&1; then
        sr_stop
    fi

    if [ -f "$PID_FILE" ]; then
        local pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            log_msg "Stopping TrustTunnel (PID $pid)"
            kill "$pid"
            local i=0
            while [ $i -lt 10 ] && kill -0 "$pid" 2>/dev/null; do
                sleep 1
                i=$((i + 1))
            done
            kill -0 "$pid" 2>/dev/null && kill -9 "$pid"
        fi
        rm -f "$PID_FILE"
    fi

    rm -f "$START_TS_FILE" "$HC_STATE_FILE"
    write_status_json
    log_msg "Stopped"
}

health_check() {
    if [ "$HC_ENABLED" != "yes" ]; then
        echo "ok" > "$HC_STATE_FILE"
        return 0
    fi

    local curl_opts="--connect-timeout $HC_CURL_TIMEOUT -s -o /dev/null -w %{http_code}"
    if [ "$TT_MODE" = "socks5" ]; then
        curl_opts="$curl_opts --proxy socks5h://$HC_SOCKS5_PROXY"
    fi

    local code
    code=$(curl $curl_opts "$HC_TARGET_URL" 2>/dev/null)

    if [ "$code" = "204" ] || [ "$code" = "200" ]; then
        echo "ok" > "$HC_STATE_FILE"
        return 0
    else
        echo "fail" > "$HC_STATE_FILE"
        return 1
    fi
}

watchdog_loop() {
    local fail_count=0
    local rotate_counter=0

    sleep "$HC_GRACE_PERIOD"

    while true; do
        rotate_counter=$((rotate_counter + 1))
        if [ "$rotate_counter" -ge 20 ]; then
            rotate_log
            rotate_counter=0
        fi

        if [ ! -f "$PID_FILE" ] || ! kill -0 "$(cat "$PID_FILE" 2>/dev/null)" 2>/dev/null; then
            log_msg "Watchdog: process died, restarting"
            start_client
            fail_count=0
            sleep "$HC_GRACE_PERIOD"
            continue
        fi

        if ! health_check; then
            fail_count=$((fail_count + 1))
            log_msg "Watchdog: health check failed ($fail_count/$HC_FAIL_THRESHOLD)"
            if [ "$fail_count" -ge "$HC_FAIL_THRESHOLD" ]; then
                log_msg "Watchdog: threshold reached, restarting"
                stop_client
                sleep 3
                start_client
                fail_count=0
                sleep "$HC_GRACE_PERIOD"
                continue
            fi
        else
            fail_count=0
        fi

        write_status_json
        sleep "$HC_INTERVAL"
    done
}

start_watchdog() {
    stop_watchdog
    load_config
    watchdog_loop &
    echo "$!" > "$WATCHDOG_PID_FILE"
    log_msg "Watchdog started (PID $!)"
}

stop_watchdog() {
    if [ -f "$WATCHDOG_PID_FILE" ]; then
        local pid=$(cat "$WATCHDOG_PID_FILE")
        kill "$pid" 2>/dev/null
        rm -f "$WATCHDOG_PID_FILE"
    fi
}

case "$1" in
    start)
        start_client
        ;;
    stop)
        stop_client
        ;;
    restart)
        stop_client
        sleep 2
        start_client
        ;;
    reload)
        load_config
        log_msg "Configuration reloaded"
        ;;
    status)
        write_status_json
        cat "$STATUS_JSON" 2>/dev/null
        ;;
    check)
        health_check
        echo "Health: $(cat "$HC_STATE_FILE" 2>/dev/null)"
        ;;
    *)
        echo "Usage: $0 {start|stop|restart|reload|status|check}"
        exit 1
        ;;
esac

exit 0
